
# switch backend
# C:\Users\lfeio\.keras\keras.json

import os
os.environ["CUDA_DEVICE_ORDER"] = "PCI_BUS_ID"   # see issue #152
#os.environ["CUDA_VISIBLE_DEVICES"] = "-1" # use CPU
os.environ["CUDA_VISIBLE_DEVICES"] = "" # use GPU

#reset kernel


import glob
import numpy as np
from PIL import Image

x_trainlist = glob.glob('d:/dat264/dataset/x_train/*.png')
x_testlist = glob.glob('d:/dat264/dataset/x_test/*.png')

x_train = np.array([np.array(Image.open(fname)) for fname in x_trainlist])
x_test = np.array([np.array(Image.open(fname)) for fname in x_testlist])

y_train = np.loadtxt("d:/dat264/dataset/y_train.csv")
y_test = np.loadtxt("d:/dat264/dataset/y_test.csv")









import keras
from keras.datasets import mnist
from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten
from keras.layers import Conv2D, MaxPooling2D
from keras import backend as K
from keras.utils import np_utils

#image set up
batch_size = 256
num_classes = 4
epochs = 50
img_rows, img_cols = 64, 64

if K.image_data_format() == 'channels_first':
    x_train = x_train.reshape(x_train.shape[0], 1, img_rows, img_cols)
    x_test = x_test.reshape(x_test.shape[0], 1, img_rows, img_cols)
    input_shape = (1, img_rows, img_cols)
else:
    x_train = x_train.reshape(x_train.shape[0], img_rows, img_cols, 1)
    x_test = x_test.reshape(x_test.shape[0], img_rows, img_cols, 1)
    input_shape = (img_rows, img_cols, 1)
    
x_train = x_train.astype('float32')
x_test = x_test.astype('float32')
x_train /= 255
x_test /= 255
print('x_train shape:', x_train.shape)
print(x_train.shape[0], 'train samples')
print(x_test.shape[0], 'test samples')


y_train = keras.utils.to_categorical(y_train, num_classes)
y_test = keras.utils.to_categorical(y_test, num_classes)







#create convolutional neural network
model = Sequential()

model.add(Conv2D(32, (3, 3), padding='valid', activation='relu', input_shape=input_shape))
model.add(Conv2D(32, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))

model.add(Conv2D(64, (3, 3), padding='valid', activation='relu'))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))

model.add(Conv2D(128, (3, 3), padding='valid', activation='relu'))
model.add(Conv2D(128, (3, 3), activation='relu'))


model.add(Flatten())
model.add(Dense(512, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(num_classes, activation='softmax'))

model.compile(optimizer='rmsprop', 
              loss='categorical_crossentropy', 
              metrics=['accuracy'])
 






#data augmentation
from keras.preprocessing.image import ImageDataGenerator
 
datagen = ImageDataGenerator(
        zoom_range=0.2, # randomly zoom into images
        rotation_range=0,  # randomly rotate images in the range (degrees, 0 to 180)
        width_shift_range=0.1,  # randomly shift images horizontally (fraction of total width)
        height_shift_range=0.1,  # randomly shift images vertically (fraction of total height)
        horizontal_flip=False,  # randomly flip images
        vertical_flip=False)  # randomly flip images
 
# ##### ##### #####
# model training
# ##### ##### #####
# Fit the model on the batches generated by datagen.flow().
history = model.fit_generator(datagen.flow(x_train, y_train, batch_size=batch_size),
                              steps_per_epoch=int(np.ceil(x_train.shape[0] / float(batch_size))),
                              epochs=epochs,
                              validation_data=(x_test, y_test),
                              workers=4)
 

score = model.evaluate(x_test, y_test, verbose=0)
print('Test loss:', score[0])
print('Test accuracy:', score[1])











# https://www.learnopencv.com/image-classification-using-convolutional-neural-networks-in-keras/
import matplotlib.pyplot as plt


# Loss Curves
plt.figure(figsize=[8,6])
plt.plot(history.history['loss'],'r',linewidth=3.0)
plt.plot(history.history['val_loss'],'b',linewidth=3.0)
plt.legend(['Training Loss', 'Validation Loss'],fontsize=18)
plt.xlabel('Epochs ',fontsize=16)
plt.ylabel('Loss',fontsize=16)
plt.title('Loss Curves',fontsize=16)
 
# Accuracy Curves
plt.figure(figsize=[8,6])
plt.plot(history.history['acc'],'r',linewidth=3.0)
plt.plot(history.history['val_acc'],'b',linewidth=3.0)
plt.legend(['Training Accuracy', 'Validation Accuracy'],fontsize=18)
plt.xlabel('Epochs ',fontsize=16)
plt.ylabel('Accuracy',fontsize=16)
plt.title('Accuracy Curves',fontsize=16)









#predict a single image

fname = 'd:/dat264/dataset/test/200012.png'

import matplotlib.image as mpimg
image = mpimg.imread(fname)
plt.imshow(image)
plt.show()
test_image = np.array([np.array(Image.open(fname))])
test_image = test_image.reshape(test_image.shape[0], img_rows, img_cols, 1)
result = model.predict(test_image)

print(result)
print(result[0])
print(result[0][0])

ori_b = np.array([1., 0., 0., 0.])
ori_r = np.array([0., 1., 0., 0.])
ori_t = np.array([0., 0., 1., 0.])
ori_l = np.array([0., 0., 0., 1.])

if np.array_equal(result[0], ori_b):
    orientation = 0
elif np.array_equal(result[0], ori_r):
    orientation = 1
elif np.array_equal(result[0], ori_t):
    orientation = 2
elif np.array_equal(result[0], ori_l):
    orientation = 3
else:
    orientation = 999
print(orientation)





'''
testlist = glob.glob('d:/dat264/dataset/test/*.png')
for fname in testlist:
    test_image = np.array([np.array(Image.open(fname))])
    test_image = test_image.reshape(test_image.shape[0], img_rows, img_cols, 1)
    result = model.predict(test_image)
    # print( int(round(result[0][0])) )
    
    
    if np.array_equal(result[0], ori_b):
        orientation = 0
    elif np.array_equal(result[0], ori_r):
        orientation = 1
    elif np.array_equal(result[0], ori_t):
        orientation = 2
    elif np.array_equal(result[0], ori_l):
        orientation = 3
    else:
        orientation = 999
    print(orientation)
    
    r = str(orientation)
    with open('d:/dat264/submit001.csv','a') as f:
        f.write(fname + ',' + r + '\r')

'''




































